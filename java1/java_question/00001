A JAR (Java ARchive) file is a package file format in Java that bundles together multiple Java classes, metadata, and resources (like text files or images) into a single compressed file. It is essentially a ZIP file with a .jar extension, designed specifically for distributing and deploying Java applications or libraries.

Key Features of a JAR File:
Packaging: A JAR file packages together all the Java .class files (compiled bytecode), libraries, and other resources needed by a Java application. This makes it easier to distribute and deploy Java applications.

Execution: A JAR file can be executable if it contains a Main-Class entry in its MANIFEST.MF file (metadata for the JAR). This allows you to run the application from the command line directly using:

java -jar myapp.jar

Random Access Interface

----------

Marker Interface

âœ… Marker Interface in Java
A Marker Interface is an interface without any methods or fields. It is used to mark or tag a class to indicate some metadata to the JVM or frameworks at runtime.

ðŸ”§ Examples in Java:
Serializable â€“ Marks a class as serializable

Cloneable â€“ Allows object cloning using clone()

Remote â€“ Indicates remote method invocation (RMI)

RandomAccess â€“ Marks fast random access in List implementations like ArrayList

ðŸ§  Purpose:
Instead of functionality, itâ€™s used for:

Type identification

Special treatment by Java runtime or frameworks


----------


Iterable

----------


Load Factor of hashmap
Load Factor is a measure of how full the HashMap can get before it needs to resize (rehash). It is defined as:
loadFactor = numberOfEntries / capacity

----------

âœ… Functional Interface in Java
A functional interface is an interface that contains only one abstract method. It can have default or static methods, but only one method must be abstract.

ðŸ§  Why it matters:
Functional interfaces are the foundation of lambda expressions and method references in Java (from Java 8 onward).

âœ… Example:

@FunctionalInterface
interface MyFunctionalInterface {
    void execute();
}
You can use it like this:

MyFunctionalInterface obj = () -> System.out.println("Running");
obj.execute();
ðŸ”§ Built-in Functional Interfaces (from java.util.function):
Runnable â€“ no arguments, no return

Supplier<T> â€“ returns a result, takes no input

Consumer<T> â€“ takes input, returns nothing

Function<T, R> â€“ takes input, returns output

Predicate<T> â€“ takes input, returns boolean


----------


Generic methods

checked and unchecked exceptions

memories of young and old generation java wht is it?

â—¯ Java Basics
   â—¦ Data types and variables
   â—¦ Operators
   â—¦ Control statements (if-else, switch, loops)
â—¯ Classes and Objects
   â—¦ "this" keyword
   â—¦ access control
   â—¦ "static" keyword
   â—¦ "final" keyword
   â—¦ Inner Class
â—¯ Object-Oriented Programming (OOP)
   â—¦ Classes and objects
   â—¦ Constructors
   â—¦ Inheritance
   â—¦ Polymorphism (method overloading and overriding)
   â—¦ Abstraction
   â—¦ Encapsulation
   â—¦ Interfaces and abstract classes
â—¯ Collections Framework
   â—¦ List, Set, and Map interfaces
   â—¦ ArrayList, LinkedList, HashSet, TreeSet, HashMap, LinkedHashMap, TreeMap
   â—¦ Iterators and enhanced for loop
   â—¦ Comparable and Comparator
â—¯ String Handling
   â—¦ Theory
   â—¦ String Constructors
   â—¦ String Length
   â—¦ String Operations
   â—¦ Character Extraction
   â—¦ String Comparision
   â—¦ Searching Strings
   â—¦ Modifying Strings
   â—¦ Data Conversion using valueOf()
   â—¦ StringBuffer
   â—¦ StringBuilder
â—¯ Multithreading and Concurrency
   â—¦ Thread lifecycle
   â—¦ Creating and managing threads
   â—¦ Synchronization
   â—¦ Concurrency utilities (Executor framework, CountDownLatch, CyclicBarrier)
â—¯ Core Java Concepts
   â—¦ JVM vs JRE vs JDK
   â—¦ Memory Management
   â—¦ Garbage Management
â—¯ Exception Handling
   â—¦ try, catch, finally
   â—¦ throw and throws
   â—¦ Custom exceptions
â—¯ Enums, Autoboxing and Annotations
   â—¦ Enumerations
   â—¦ values() and valueOf()
   â—¦ Wrappers
   â—¦ Autoboxing
   â—¦ Unboxing
   â—¦ Annotations (Metadata)
   â—¦ Built-In Annotations
â—¯ Generics
   â—¦ What are Generics
   â—¦ Bounded Types
â—¯ Java 8 Features
   â—¦ Functional interfaces and Lambda expressions
   â—¦ Streams API
   â—¦ Optional class
   â—¦ Default and static methods in interfaces
   â—¦ Date and Time API (java.time package)
â—¯ JVM Internals
   â—¦ JVM architecture
   â—¦ Class loading mechanism
   â—¦ Memory management (heap, stack)
   â—¦ Garbage collection
â—¯ Java Memory Model
   â—¦ Understanding volatile and atomic variables
   â—¦ Thread safety
   â—¦ Happens-before relationship
â—¯ Java I/O
   â—¦ File handling (File class)
   â—¦ Byte streams (InputStream, OutputStream)
   â—¦ Character streams (Reader, Writer)
   â—¦ Serialization and Deserialization
â—¯ Design Patterns
   â—¦ Creational patterns (Singleton, Factory, Builder)
   â—¦ Structural patterns (Adapter, Composite, Decorator)
   â—¦ Behavioral patterns (Strategy, Observer, Command)





JDK stream
