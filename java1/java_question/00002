ðŸ”¹ Core Java

Difference between JDK, JRE, and JVM?

Explain HashMap internal working in Java 8 and Java 11.

Difference between equals() and ==.

Why is String immutable in Java?

Explain volatile keyword and happens-before relationship.

What are checked vs unchecked exceptions?

What is the difference between final, finally, and finalize()?

Explain Java memory model (Heap, Stack, PermGen/Metaspace, GC).

Difference between ArrayList and LinkedList, and when to use each.

Explain fail-fast vs fail-safe iterators.

ðŸ”¹ OOP & Design

Difference between abstract class and interface.

What is polymorphism with real-world example?

Explain SOLID principles in Java.

What are design patterns youâ€™ve used (Singleton, Factory, Builder, Strategy)?

What is dependency injection, and how does Spring manage it?

ðŸ”¹ Multithreading & Concurrency

Difference between Thread, Runnable, and Callable.

Explain synchronized, Lock, and ReentrantLock.

What is a deadlock? How do you prevent it?

Difference between ConcurrentHashMap and Collections.synchronizedMap().

How does ThreadPoolExecutor work internally?

ðŸ”¹ Java 8+ Features

Difference between Stream API and Collections API.

How do lambdas and functional interfaces work?

What is the difference between map() and flatMap()?

Explain Optional class and best practices.

Difference between parallelStream() and stream().

ðŸ”¹ JVM & Performance

How does Garbage Collection (GC) work?

What are different GC algorithms (Serial, Parallel, G1, ZGC)?

How do you find memory leaks in Java applications?

Explain class loading mechanism (Bootstrap, Extension, Application classloaders).

Difference between stack memory and heap memory.

ðŸ”¹ Advanced / Real-World

How do you handle high concurrency in a web application?

Explain immutability and why itâ€™s important in multithreading.

How do you implement caching in Java?

How would you design a thread-safe Singleton?

What are best practices for writing clean, reusable Java code?

âœ… Tip for interviews: Donâ€™t just memorize definitions. For each question, be ready with:

Concept explanation

Small code example

Real-world use case (this sets you apart).

ðŸ‘‰ Do you want me to create a detailed Q&A guide (with answers + code examples) for these 35, or should I first give you the most commonly repeated 10 questions with answers to focus on?

You said:
answer them
Java Interview Pro said:

Alright, letâ€™s tackle this systematically. Since you asked for answers to all 35 questions, Iâ€™ll give you concise but job-ready answers â€” not bookish, but the way interviewers expect:

ðŸ”¹ Core Java
1. Difference between JDK, JRE, JVM

JDK = Development kit (compiler javac, debugger, tools + JRE).

JRE = Runtime environment (JVM + libraries needed to run).

JVM = Abstract machine that runs bytecode, platform-independent.

ðŸ‘‰ JDK = JRE + development tools.

2. HashMap internal working (Java 8 vs 11)

Pre-Java 8: HashMap used array + linked list for collisions.

Java 8+: If a bucket has >8 entries, the list is converted into a balanced tree (Red-Black Tree) for O(log n) lookup.

Hash function spreads keys to reduce collisions.

3. equals() vs ==

== â†’ compares references (are they same object?).

equals() â†’ compares content (if overridden properly, e.g., in String).

4. Why is String immutable?

Caching: String literals stored in String pool.

Security: Prevents changes in sensitive data like DB URLs, class names.

Thread-safety: Immutable objects are naturally thread-safe.

5. Volatile + Happens-Before

volatile ensures visibility (changes to a variable are seen by all threads immediately).

It does not guarantee atomicity.

Happens-before rule: If one action happens-before another, the first is visible and ordered before the second.

6. Checked vs Unchecked exceptions

Checked: must be handled/declared (IOException, SQLException).

Unchecked: runtime errors (NullPointerException, ArithmeticException).

7. final, finally, finalize()

final â†’ keyword (constant, method overriding restriction, class inheritance restriction).

finally â†’ block in try-catch (guaranteed execution).

finalize() â†’ GC hook (deprecated in Java 9).

8. Java memory model

Heap: Objects + GC-managed.

Stack: Local variables, method calls.

Metaspace (Java 8+) â†’ stores class metadata (replaces PermGen).

9. ArrayList vs LinkedList

ArrayList: backed by array â†’ fast random access (O(1)) but slow insert/delete in middle.

LinkedList: nodes with prev/next pointers â†’ fast insert/delete (O(1)) but slow random access (O(n)).

10. Fail-fast vs Fail-safe

Fail-fast: Throws ConcurrentModificationException (e.g., ArrayList, HashMap iterators).

Fail-safe: Iterates over a copy (e.g., ConcurrentHashMap, CopyOnWriteArrayList).

ðŸ”¹ OOP & Design
11. Abstract class vs Interface

Abstract class: can have fields + constructors + partial implementation.

Interface: pure contract, Java 8+ allows default/static methods.

Prefer interface for multiple inheritance of behavior.

12. Polymorphism

Compile-time (method overloading).

Runtime (method overriding).
ðŸ‘‰ Example: Animal.speak() overridden by Dog and Cat.

13. SOLID principles

S: Single responsibility

O: Open-closed

L: Liskov substitution

I: Interface segregation

D: Dependency inversion

14. Design patterns youâ€™ve used

Singleton (Logger, Config).

Factory (object creation).

Builder (complex object creation).

Strategy (replaceable algorithms).

15. Dependency Injection

Instead of creating objects with new, objects are injected (via Spring, Guice, etc).

Promotes loose coupling + easier testing.

ðŸ”¹ Multithreading & Concurrency
16. Thread vs Runnable vs Callable

Thread: Extends Thread class.

Runnable: Functional interface, run() returns void.

Callable: Returns a result (Future<T>).

17. synchronized vs Lock vs ReentrantLock

synchronized: implicit lock, automatic release.

Lock: explicit lock/unlock, tryLock possible.

ReentrantLock: supports fairness, interruptible lock waiting.

18. Deadlock & prevention

Deadlock â†’ circular waiting on locks.
Prevention strategies:

Acquire locks in a fixed order.

Use tryLock() with timeout.

19. ConcurrentHashMap vs synchronizedMap

synchronizedMap: whole map locked (blocking).

ConcurrentHashMap: bucket-level locks, allows concurrent reads and partial writes.

20. ThreadPoolExecutor

Manages worker threads.

Uses core pool, max pool, queue, rejection policy.

Reduces thread creation overhead.

ðŸ”¹ Java 8+ Features
21. Stream API vs Collections API

Collections: store + manipulate data.

Streams: process data in a functional style (map, filter, reduce).

22. Lambdas + Functional interfaces

Lambda â†’ compact syntax for anonymous function.

Functional interface â†’ exactly 1 abstract method (Runnable, Comparator).

23. map() vs flatMap()

map() â†’ transforms elements 1-to-1.

flatMap() â†’ flattens nested structures (e.g., List<List<T>> â†’ List<T>).

24. Optional class

Wrapper for values that may/may not exist.

Avoids NullPointerException.

Methods: orElse(), ifPresent(), map().

25. parallelStream() vs stream()

stream() â†’ sequential execution.

parallelStream() â†’ parallel processing using ForkJoinPool.

Use only when tasks are independent and CPU-bound.

ðŸ”¹ JVM & Performance
26. Garbage Collection

JVM automatically reclaims memory of unused objects.

GC roots â†’ determine reachability.

27. GC Algorithms

Serial GC â†’ single-threaded.

Parallel GC â†’ multi-threaded.

G1 GC â†’ region-based, low pause.

ZGC/Shenandoah â†’ ultra-low pause, scalable.

28. Finding memory leaks

Tools: VisualVM, JProfiler, Eclipse MAT.

Symptoms: OutOfMemoryError, GC thrashing.

29. Class loading mechanism

Bootstrap â†’ loads core Java classes.

Extension â†’ loads extension libs.

Application â†’ loads app classes.

Parent delegation model.

30. Stack vs Heap memory

Stack: method calls, local vars, thread-private.

Heap: objects, shared across threads.

ðŸ”¹ Advanced / Real-World
31. Handling high concurrency

Use ConcurrentHashMap, ThreadPoolExecutor, non-blocking algorithms.

Apply caching, async processing, load balancing.

32. Immutability & multithreading

Immutable objects are thread-safe by default.

Example: String, Integer.

33. Caching in Java

In-memory (ConcurrentHashMap, Guava).

Distributed (Redis, Hazelcast, Ehcache).

34. Thread-safe Singleton
public class Singleton {
    private static volatile Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) instance = new Singleton();
            }
        }
        return instance;
    }
}

35. Clean, reusable code practices

Follow SOLID principles.

Use design patterns when appropriate.

Write unit tests.

Avoid God classes.

Prefer composition over inheritance.
