Multithreading in java

https://www.geeksforgeeks.org/java-multithreading-tutorial/

Threads are the backbone of multithreading. We are living in the real world which in itself is caught on the web surrounded by
lots of applications. With the advancement in technologies, we cannot achieve the speed required to run them simultaneously unless
we introduce the concept of multi-tasking efficiently. It is achieved by the concept of thread.


Real-life Example of Java Multithreading

Suppose you are using two tasks at a time on the computer, be it using Microsoft Word and listening to music.
These two tasks are called  processes  . So you start typing in Word and at the same time start music app, this is called  multitasking  .
Now you committed a mistake in a Word and spell check shows exception, this means Word is a process that is broken down into sub-processes. 
Now if a machine is dual-core then one process or task is been handled by one core and music is been handled by another core. 

In the above example, we come across both multiprocessing and multithreading.
These are somehow indirectly used to achieve multitasking. In this way the mechanism of dividing the tasks is called multithreading
in which every process or task is called by a thread where a thread is responsible for when to execute, when to stop and
how long to be in a waiting state. 

Hence, a thread is the smallest unit of processing whereas multitasking is a process of executing multiple tasks at a time.

Multitasking is being achieved in two ways :

Multiprocessing : 

Process-based multitasking is a heavyweight process and occupies different address spaces in memory. 
Hence, while switching from one process to another, it will require some time be it very small, causing a lag because of switching.
This happens as registers will be loaded in memory maps and the list will be updated.

Multithreading : 

Thread-based multitasking is a lightweight process and occupies the same address space.
Hence, while switching cost of communication will be very less.



Q. If there multiple cores, then also switching takes time ?

Ans.

Yes, even with multiple cores, process switching still takes time, though the impact can vary depending on the system architecture and the specifics of the workload. Here's a more detailed explanation of what happens:
So basically even if multiple cores use the same shared memory RAM cache and IO resources, then it takes time. 
Only if each cores is completely independent have its oen resources then it is call parallel processing and is truly efficient.

üß† Process Switching on Multiple Cores
Multicore Processor: A multicore processor has more than one CPU core, allowing multiple processes or threads to run concurrently on different cores. In this case, you can have several processes or threads running simultaneously, each on its own core.

Context Switching: Even with multiple cores, when the operating system decides to switch a process or thread (known as a context switch), the system needs to:

Save the state (context) of the current process/thread (e.g., CPU registers, program counter).

Load the state of the next process/thread to be executed.

Inter-core Switching: If the process or thread is moved from one core to another (which can happen due to scheduling decisions), the operating system needs to handle the communication between cores and potentially move cache data between them. This can introduce some latency because:

Cache coherence: Different cores may have different cached data. Moving a process between cores might require invalidating or updating caches.

Synchronization overhead: Ensuring that shared data is properly synchronized between cores can add additional overhead, particularly if memory access needs to be coordinated.

üïí Time Taken for Switching
Switching time can be broken down into several components:

Context Switching: When a process is switched, the operating system saves the state of the current process and loads the state of the next process. This process takes time, whether the task runs on a single core or multiple cores. The time is typically in the range of microseconds, but still noticeable.

Cache Misses: When switching between cores, the new process might not benefit from the previous core's cache. This can result in more cache misses and memory accesses, which can add latency when switching between cores.

Inter-process Communication (IPC): If processes need to share data, this often involves communication between cores, which can add latency, particularly if there's contention for shared resources (like memory).

Operating System Overhead: The OS itself needs to schedule processes, which can introduce additional overhead. This scheduling process involves deciding which process gets to run on which core, and the decision-making can take some time, particularly if the scheduler is complex.

üßë‚Äçüíª When Multiple Cores Help
True Parallelism: With multiple cores, processes can execute truly in parallel, without the need for switching. This is especially useful for CPU-bound tasks that can be split into smaller independent tasks (such as in parallel computing).

Reduced Overall Latency: By spreading tasks across different cores, you can reduce the overall system load and avoid a situation where a single core is overloaded, leading to excessive switching.

‚è≥ Conclusion
Process Switching Still Takes Time: Even with multiple cores, switching between processes still takes time due to the need for context saving, restoring, cache synchronization, and possible inter-core communication.

Benefit of Multiple Cores: The real advantage of multiple cores comes when you have multiple threads or processes running in parallel. This allows you to minimize the time a single process spends on the CPU by distributing the load, but it does not eliminate the time taken for switching when required.



------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



Thread Lifecycle

Please check the correct diagram here

https://www.geeksforgeeks.org/lifecycle-and-states-of-a-thread-in-java/

+------------------------+
|         New             |
|------------------------|
| - Thread is created     |
| - Not yet started       |
+------------------------+
          |
          | start() 
          v
+------------------------+
|       Runnable          |
|------------------------|
| - Thread is ready to    |
|   run, waiting for CPU  |
|   time to be allocated  |
+------------------------+
          |
          | run()
          v
+------------------------+
|       Running           |
|------------------------|
| - Thread is executing   |
|   the code in the run() |
|   method                |
+------------------------+
          |
          | sleep(ms), join(), wait(), ( interrupt() can cause Exception here)
          v
+------------------------+
|       Blocked           |
|------------------------|
| - Waiting for a lock    |
|   or resource           |
+------------------------+
          |
          | wait()
          v
+------------------------+
|       Waiting           |                                                         
|------------------------|                                                          
| - Waiting for a signal  | 
|   or condition to be    |
|   met                   |
+------------------------+
          |                                                                       
          |     notify(), ( interrupt() can cause Exception here)
          | 
          v
+------------------------+
|       Running           |
|------------------------|
| - Thread is executing   |
|   the code remaining    |
|                         |
+------------------------+   
          |                                                                       
          |
          | interrupt() , stop(), automatic exit of main method
          v
+------------------------+
|       Terminated        |
|------------------------|
| - Thread has finished   |
|   execution or was      |
|   interrupted           |
+------------------------+



Key Java Methods & Transitions:

start(): Transitions the thread from the New state to Runnable.

run(): The run() method is executed when the thread is in the Running state.

sleep(ms): Moves the thread to the Blocked state for the specified time.

join(): Moves the thread to Blocked until the specified thread completes.

wait(): Causes the current thread to release the lock and enter the Waiting state until notified.

notify() / notifyAll(): Wakes up one or more threads that are waiting on the object's monitor.

interrupt(): Interrupts the thread, potentially causing it to leave Blocked or Waiting and move to the Terminated state if an exception is thrown.

Q. If interrupt is called before waiting state it should not go to waiting state right directly go to termination state ?

Explanation of interrupt() Behavior:

interrupt():

If the thread is in the Waiting state (waiting for a signal or condition), it will not stay in the Waiting state. Instead, it will move to the Terminated state, often throwing an InterruptedException.

If the thread is running or sleeping, it can be interrupted, causing it to throw an exception or exit its current state.

This adjustment ensures that interrupt() leads to proper termination or handling of the thread, instead of leaving it stuck in the Waiting state.



Below is the Lifecycle of a Thread been illustrated
New : When a thread is just created.
Runnable : When a start() method is called over thread processed by the thread scheduler.
Case A: Can be a running thread
Case B: Can not be a running thread
Running : When it hits case 1 means the scheduler has selected it to be run the thread from runnable state to run state.
Blocked : When it hits case 2 meaning the scheduler has selected not to allow a thread to change state from runnable to run.
Terminated : When the run() method exits or stop() method gets called.


------------------------------------------------------------------------------------------------------------------------------------------------


In operating systems, process scheduling algorithms are used to manage the execution of processes (or threads) by the CPU.
When multiple processes or threads are ready to run, the scheduler needs to decide which one to execute next.
These algorithms determine the order in which processes (or threads) are scheduled for execution.
Incorporating threads into these scheduling algorithms means that the operating system not only handles processes 
(which are instances of running programs) but also manages threads (which are the smallest units of execution within processes).
First In First Out
Last In First Out
Round Robin Scheduling


------------------------------------------------------------------------------------------------------------------------------------------------


isDaemon()	It checks whether the current thread is daemon or not
setDaemon()	It set the current thread as Daemon thread
start()	It starts the execution of the thread
run()	It does the executable operations statements in the body of this method over a thread
Thread.sleep()	It is a static method that puts the thread to sleep for a certain time been passed as an argument to it
wait()	It sets the thread back in waiting state.
notify()	It gives out a notification to one thread that is in waiting state. It‚Äôs used to wake up only one thread that‚Äôs waiting for an object,
notifyAll()	It gives out a notification to all the thread in the waiting state
stop()	It is used to stop the execution of the thread
public String getName() ;
public void setName(String name);
suspend() Method :The suspend() method of thread class puts the thread from running to waiting state. This method is employed if you would like to prevent the thread execution and begin it again when a particular event occurs. This method allows a thread to temporarily cease execution. The suspended thread is often resumed using the resume() method.
resume()	It is used to resume the suspended thread.
currentThread().getName() 
getName()
setName() 
getState()
getPriority()
------------------------------------------------------------------------------------------------------------------------------------------------

Q. Diff between wait and join

wait()	                                                                                join()
It is a method of java.lang.Object class.	                                              It is a method of java.lang.
wait() method can be called by a synchronized block or method.	                        It is used to pause the current thread and wait for the thread.join() to complete .
wait() method is implemented for performing multi-thread-synchronization.	              It can be called either with synchronized and without synchronized context.
Its syntax is -:   public final void wait() throws InterruptedException                 Its syntax is -: public final void join() throws InterruptedException 
wait() method causes the thread to sleep until notify() and notifyAll() are called	    It can be used to add sequence among more than one thread


------------------------------------------------------------------------------------------------------------------------------------------------


Two Ways to Implement Multithreading
Using Thread Class
Using Runnable Interface

------------------------------------------------------------------------------------------------------------------------------------------------


1. Using Thread Class

// Case 1
// Java Program to illustrate Creation and execution of
// thread via start() and run() method in Single inheritance

// Class 1
// Helper thread Class extending main Thread Class
class MyThread1 extends Thread {

    // Method inside MyThread2
    // run() method which is called as
    // soon as thread is started
    public void run()
    {

        // Print statement when the thread is called
        System.out.println("Thread1 is running");
    }
}

// Class 2
// Main thread Class extending main Thread Class
class MyThread2 extends Thread {

    // Method inside MyThread2
    // run() method which is called 
    // as soon as thread is started
    public void run()
    {

        // run() method which is called as soon as thread is
        // started

        // Print statement when the thread is called
        System.out.println("Thread2 is running");
    }
}

// Class 3
// Main Class
class GFG {

    // Main method
    public static void main(String[] args)
    {

        // Creating a thread object of our thread class
        MyThread1 obj1 = new MyThread1();
        MyThread2 obj2 = new MyThread2();

        // Getting the threads to the run state

        // This thread will transcend from runnable to run
        // as start() method will look for run() and execute
        // it
        obj1.start();

        // This thread will also transcend from runnable to
        // run as start() method will look for run() and
        // execute it
        obj2.start();
    }
}






or without comments







class MyThread1 extends Thread {
    public void run()
    {
        System.out.println("Thread1 is running");
    }
}

class MyThread2 extends Thread {
    public void run()
    {
        System.out.println("Thread2 is running");
    }
}

class GFG {
    public static void main(String[] args)
    {
        MyThread1 obj1 = new MyThread1();
        MyThread2 obj2 = new MyThread2();
        obj1.start();
        obj2.start();
    }
}





2. Using Runnable Interface


// Java Program to illustrate Runnable Interface in threads
// as multiple inheritance is not allowed

// Importing basic packages
import java.io.*;
import java.util.*;

// Class 1
// Helper class implementing Runnable interface
class MyThread1 implements Runnable {

    // run() method inside this class
    @Override
    public void run()
    {
        // Iterating to get more execution of threads
        for (int i = 0; i < 5; i++) {

            // Print statement whenever run() method
            // of this class is called
            System.out.println("Thread1");

            // Getting sleep method in try block to
            // check for any exceptions
            try {
                // Making the thread pause for a certain
                // time using sleep() method
                Thread.sleep(1000);
            }

            // Catch block to handle the exceptions
            catch (Exception e) {
            }
        }
    }
}

// Class 2
// Helper class implementing Runnable interface
class MyThread2 implements Runnable {

    // run() method inside this class
    @Override
    public void run()
    {
        for (int i = 0; i < 5; i++) {

            // Print statement whenever run() method
            // of this class is called
            System.out.println("Thread2");

            // Getting sleep method in try block to
            // check for any exceptions
            try {

                // Making the thread pause for a certain
                // time
                // using sleep() method
                Thread.sleep(1000);
            }

            // Catch block to handle the exceptions
            catch (Exception e) {
            }
        }
    }
}

// Class 3
// Main class
public class GFG {

    // Main driver method
    public static void main(String[] args)
    {

        // Creating reference of Runnable to
        // our classes above in main() method
        Runnable obj1 = new MyThread1();
        Runnable obj2 = new MyThread2();

        // Creating reference of thread class
        // by passing object of Runnable in constructor of
        // Thread class
        Thread t1 = new Thread(obj1);
        Thread t2 = new Thread(obj2);

        // Starting the execution of our own run() method
        // in the classes above
        t1.start();
        t2.start();
    }
}




or
// without comments


import java.io.*;
import java.util.*;
class MyThread1 implements Runnable {
    @Override
    public void run()
    {
        for (int i = 0; i < 5; i++) {
            System.out.println("Thread1");
            try {
                Thread.sleep(1000);
            }
            catch (Exception e) {
            }
        }
    }
}
class MyThread2 implements Runnable {
    @Override
    public void run()
    {      for (int i = 0; i < 5; i++) {
            System.out.println("Thread2");
            try {
                Thread.sleep(1000);
            }
            catch (Exception e) {
            }
        }
    }
}
public class GFG {
    public static void main(String[] args)
    {
        Runnable obj1 = new MyThread1();
        Runnable obj2 = new MyThread2();
        Thread t1 = new Thread(obj1);
        Thread t2 = new Thread(obj2);
        t1.start();
        t2.start();
    }
}

------------------------------------------------------------------------------------------------------------------------------------------------

Example:

Refer: https://www.geeksforgeeks.org/lifecycle-and-states-of-a-thread-in-java/


Example of Demonstrating Thread States
Below is a real-world example of a ticket booking system that demonstrates different thread states:



// Java program to demonstrate thread states 
// using a ticket booking scenario
class TicketBooking implements Runnable {
    @Override
    public void run() {
        
        try {
            
            // Timed waiting
            Thread.sleep(200); 
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("State of MainThread while mainThread is waiting: " +
                TicketSystem.mainThread.getState());

        try {
            
            // Another timed waiting
            Thread.sleep(100); 
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class TicketSystem implements Runnable {
    public static Thread mainThread;
    public static TicketSystem ticketSystem;

    @Override
    public void run() {
        TicketBooking booking = new TicketBooking();
        Thread bookingThread = new Thread(booking);

        System.out.println("State after creating bookingThread: " + bookingThread.getState());

        bookingThread.start();
        System.out.println("State after starting bookingThread: " + bookingThread.getState());

        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("State after sleeping bookingThread: " + bookingThread.getState());

        try {
            
            // Moves mainThread to waiting state until bookingThread joins its.
            bookingThread.join(); 
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("State after bookingThread finishes: " + bookingThread.getState());
    }

    public static void main(String[] args) {
        ticketSystem = new TicketSystem();
        mainThread = new Thread(ticketSystem);

        System.out.println("State after creating mainThread: " + mainThread.getState());

        mainThread.start();
        System.out.println("State after starting mainThread: " + mainThread.getState());
    }
}

Output:


State after creating mainThread: NEW
State after starting mainThread: RUNNABLE
State after creating bookingThread: NEW
State after starting bookingThread: RUNNABLE
State after sleeping bookingThread: TIMED_WAITING
State of MainThread while mainThread is waiting: WAITING
State after bookingThread finishes: TERMINATED

------------------------------------------------------------------------------------------------------------------------------------------------

Priorities in threads is a concept where each thread is having a priority which is represented by numbers ranging from 1 to 10.

The default priority is set to 5 as excepted.
Minimum priority is set to 1.
Maximum priority is set to 10.
Here 3 constants are defined in it namely as follows:

public static int NORM_PRIORITY
public static int MIN_PRIORITY
public static int MAX_PRIORITY


// Java Program to illustrate Priority Threads
// Case 3: MIN_PRIORITY

// Importing input output thread class
import java.io.*;
// Importing Thread class from java.util package
import java.util.*;

// Class 1
// Helper Class (Our thread  class)
class MyThread extends Thread {

    // run() method to transit thread from
    // runnable to run state
    public void run()
    {

        // Printing the current running thread via getName()
        // method using currentThread() method
        System.out.println("Running Thread : "
                           + currentThread().getName());

        // Print and display the priority of current thread
        // via currentThread() using getPriority() method
        System.out.println("Running Thread Priority : "
                           + currentThread().getPriority());
    }
}

// Class 2
// Main Class
class GFG {

    // Main driver method
    public static void main(String[] args)
    {

        // Creating objects of MyThread(above class)
        // in the main() method
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();

        // Setting priority to thread via NORM_PRIORITY
        // which set priority to 1 as least priority thread
        t1.setPriority(Thread.MIN_PRIORITY);
        t2.setPriority(Thread.MIN_PRIORITY);

        // Setting default priority using
        // NORM_PRIORITY
        t1.start();
        t2.start();
    }
}

o/p

Case 3: MIN_PRIORITY

Running Thread : Thread-0
Running Thread : Thread-1
Running Thread Priority : 1
Running Thread Priority : 1


------------------------------------------------------------------------------------------------------------------------------------------------


Daemon thread is basically a service provider thread that provides services to the user thread. The scope for this thread start() or be it terminate() is completely dependent on the user's thread as it supports in the backend for user threads being getting run. As soon as the user thread is terminated daemon thread is also terminated at the same time as being the service provider thread.

Hence, the characteristics of the Daemon thread are as follows:

It is only the service provider thread not responsible for interpretation in user threads.
So, it is a low-priority thread.
It is a dependent thread as it has no existence on its own.
JVM terminates the thread as soon as user threads are terminated and come back into play as the user's thread starts.
Yes, you guess the most popular example is garbage collector in java. Some other examples do include 'finalizer'.
Exceptions: IllegalArgumentException as return type while setting a Daemon thread is boolean so do apply carefully.

 Note:  To get rid of the exception users thread should only start after setting it to daemon thread. The other way of starting prior setting it to daemon will not work as it will pop-out IllegalArgumentException 


Another way to achieve the same is through Thread Group in which as the name suggests multiple threads are treated as a single object and later on all the operations are carried on over this object itself aiding in providing a substitute for the Thread Pool.

 Note: 

 While implementing ThreadGroup do note that ThreadGroup is a part of '  java.lang.ThreadGroup'  class not a part of Thread class in java so do peek out constructors and methods of ThreadGroup class before moving ahead keeping a check over deprecated methods in his class so as not to face any ambiguity further. 
Here main() method in itself is a thread because of which you do see Exception in main() while running the program because of which system.main thread exception is thrown sometimes while execution of the program.

------------------------------------------------------------------------------------------------------------------------------------------------


Synchronization

For more depth in synchronization, one can also learn object level lock and class level lock and do notice the differences between two to get a fair understanding of the same before implementing the same.

Object Level lock on threads

An object-level lock is a mechanism when we want to synchronize a non-static method or non-static code block such that only 
one thread will be able to execute the code block on a given instance of the class. 
First, it has to get a lock of that object. Once the thread gets the lock then it
is allowed to execute any synchronized method on that object. Once method execution completes automatically thread releases the lock. 
Acquiring and releasing lock internally is taken care of by JVM and the programmer is not responsible for these activities.


public class GeekClass
{
    public synchronized void GeekMethod(){}
}

or


public class GeekClass
{
    public void GeekMethod(){
        synchronized (this)
        {
            // other thread safe code
        }
    }
}



or

// not used much

public class DemoClass
{
    private final Object lock = new Object();
    public void demoMethod(){
        synchronized (lock)
        {
            // other thread safe code
        }
    }
}


---------------

Class Level lock on threads

 If a thread wants to execute a static synchronized method, then the thread requires a class level lock. 
 Once a thread got the class level lock, then it is allowed to execute any static synchronized method of that class.
Once method execution completes automatically thread releases the lock.

public static synchronized int incrementCount()
{
}


or


public class GeekClass
{
    public void GeekMethod(){
        synchronized (GeekClass.class)
        {
            //thread has acquired lock on  Geek class
        }
    }
}


 Disadvantage:  Performance issues will arise as during the execution of one thread all the other threads are put to a  blocking state  and do note they are not in  waiting state  . This causes a  performance drop if the time taken for one thread is too long. 



 When multiple threads are working on the same data, and the value of our data is changing, that scenario is not thread-safe, and we will get inconsistent results. When a thread is already working on an object and preventing another thread from working on the same object, this process is called Thread-Safety. Now there are several ways to achieve thread-safety in our program namely as follows:

Using Synchronization
Using Volatile Keyword
Using Atomic Variable
Using Final Keyword
ReentrantLock
ReadWriteLock


What is a blocking queue?
A Blocking Queue is a type of queue in concurrent programming that provides blocking operations for managing producer-consumer scenarios. When a thread tries to retrieve an element from an empty Blocking Queue, it's blocked until another thread adds an element. Conversely, if a thread attempts to add an element to a full Blocking Queue, it's blocked until another thread removes an element. This behavior facilitates synchronization between threads, ensuring that producers and consumers work efficiently. 

A ReentrantLock allows a thread to acquire the same lock multiple times, which is particularly useful when a thread needs to access a shared resource repeatedly within its execution. It implements the Lock interface, providing greater control over locking compared to synchronized blocks.

ReentrantLock tracks a ‚Äúhold count‚Äù which is a value that starts at 1 when a thread first locks the resource. Each time the thread re-enters the lock, the count is incremented. The count is decremented when the lock is released. Once the hold count reaches zero, the lock is fully released.


Using Volatile Keyword

class SharedObj
{
   // volatile keyword here makes sure that
   // the changes made in one thread are 
   // immediately reflect in other thread
   static volatile int sharedVar = 6;
}
 we may only desire visibility and not atomicity.

Using Atomic Variable


Java provides atomic classes such as AtomicInteger, AtomicLong, AtomicBoolean and AtomicReference. Objects of these classes represent the atomic variable of int, long, boolean, and object reference respectively. These classes contain the following methods.

set(int value): Sets to the given value
get(): Gets the current value
lazySet(int value): Eventually sets to the given value
compareAndSet(int expect, int update): Atomically sets the value to the given updated value if the current value == the expected value
addAndGet(int delta): Atomically adds the given value to the current value
decrementAndGet(): Atomically decrements by one the current value

Also we have ConcurrentHashMap, BlockingQueue

Using Final Keyword

It restricts the user from accessing that particular part of the program, such as restricting the modification and inheriting the properties from the parent class or overloading.
Final methods: When a method is declared as final, it cannot be overridden by a subclass. This is useful for methods that are part of a class‚Äôs public API and should not be modified by subclasses.
Final classes:  When a class is declared as final, it cannot be extended by a subclass. This is useful for classes that are intended to be used as is and should not be modified or extended.
Final variables: Declaring a variable as final prevents its value from being changed after initialization, useful for constants.

------------------

Thread Pools in Java

https://www.geeksforgeeks.org/thread-pools-java/


Server Programs such as database and web servers repeatedly execute requests from multiple clients and these are oriented around processing a large number of short tasks. An approach for building a server application would be to create a new thread each time a request arrives and service this new request in the newly created thread. While this approach seems simple to implement, it has significant disadvantages. A server that creates a new thread for every request would spend more time and consume more system resources in creating and destroying threads than processing actual requests. Since active threads consume system resources, a JVM creating too many threads at the same time can cause the system to run out of memory. This necessitates the need to limit the number of threads being created.
What is ThreadPool in Java?

A thread pool reuses previously created threads to execute current tasks and offers a solution to the problem of thread cycle overhead and resource thrashing. Since the thread is already existing when the request arrives, the delay introduced by thread creation is eliminated, making the application more responsive.
Java provides the Executor framework which is centered around the Executor interface, its sub-interface -ExecutorService and the class-ThreadPoolExecutor, which implements both of these interfaces. By using the executor, one only has to implement the Runnable objects and send them to the executor to execute.
They allow you to take advantage of threading, but focus on the tasks that you want the thread to perform, instead of thread mechanics.
To use thread pools, we first create a object of ExecutorService and pass a set of tasks to it. ThreadPoolExecutor class allows to set the core and maximum pool size.The runnables that are run by a particular thread are executed sequentially.


// Java program to illustrate 
// ThreadPool
import java.text.SimpleDateFormat; 
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

// Task class to be executed (Step 1)
class Task implements Runnable   
{
    private String name;
    
    public Task(String s)
    {
        name = s;
    }
    
    // Prints task name and sleeps for 1s
    // This Whole process is repeated 5 times
    public void run()
    {
        try
        {
            for (int i = 0; i<=5; i++)
            {
                if (i==0)
                {
                    Date d = new Date();
                    SimpleDateFormat ft = new SimpleDateFormat("hh:mm:ss");
                    System.out.println("Initialization Time for"
                            + " task name - "+ name +" = " +ft.format(d));   
                    //prints the initialization time for every task 
                }
                else
                {
                    Date d = new Date();
                    SimpleDateFormat ft = new SimpleDateFormat("hh:mm:ss");
                    System.out.println("Executing Time for task name - "+
                            name +" = " +ft.format(d));   
                    // prints the execution time for every task 
                }
                Thread.sleep(1000);
            }
            System.out.println(name+" complete");
        }
        
        catch(InterruptedException e)
        {
            e.printStackTrace();
        }
    }
}
public class Test
{
     // Maximum number of threads in thread pool
    static final int MAX_T = 3;             

    public static void main(String[] args)
    {
        // creates five tasks
        Runnable r1 = new Task("task 1");
        Runnable r2 = new Task("task 2");
        Runnable r3 = new Task("task 3");
        Runnable r4 = new Task("task 4");
        Runnable r5 = new Task("task 5");      
        
        // creates a thread pool with MAX_T no. of 
        // threads as the fixed pool size(Step 2)
        ExecutorService pool = Executors.newFixedThreadPool(MAX_T);  
       
        // passes the Task objects to the pool to execute (Step 3)
        pool.execute(r1);
        pool.execute(r2);
        pool.execute(r3);
        pool.execute(r4);
        pool.execute(r5); 
        
        // pool shutdown ( Step 4)
        pool.shutdown();    
    }
}


o/p


Output:
Initialization Time for task name - task 2 = 02:32:56
Initialization Time for task name - task 1 = 02:32:56
Initialization Time for task name - task 3 = 02:32:56
Executing Time for task name - task 1 = 02:32:57
Executing Time for task name - task 2 = 02:32:57
Executing Time for task name - task 3 = 02:32:57
Executing Time for task name - task 1 = 02:32:58
Executing Time for task name - task 2 = 02:32:58
Executing Time for task name - task 3 = 02:32:58
Executing Time for task name - task 1 = 02:32:59
Executing Time for task name - task 2 = 02:32:59
Executing Time for task name - task 3 = 02:32:59
Executing Time for task name - task 1 = 02:33:00
Executing Time for task name - task 3 = 02:33:00
Executing Time for task name - task 2 = 02:33:00
Executing Time for task name - task 2 = 02:33:01
Executing Time for task name - task 1 = 02:33:01
Executing Time for task name - task 3 = 02:33:01
task 2 complete
task 1 complete
task 3 complete
Initialization Time for task name - task 5 = 02:33:02
Initialization Time for task name - task 4 = 02:33:02
Executing Time for task name - task 4 = 02:33:03
Executing Time for task name - task 5 = 02:33:03
Executing Time for task name - task 5 = 02:33:04
Executing Time for task name - task 4 = 02:33:04
Executing Time for task name - task 4 = 02:33:05
Executing Time for task name - task 5 = 02:33:05
Executing Time for task name - task 5 = 02:33:06
Executing Time for task name - task 4 = 02:33:06
Executing Time for task name - task 5 = 02:33:07
Executing Time for task name - task 4 = 02:33:07
task 5 complete
task 4 complete


-------------------------------------------------

Example:
one thread prints even and one thread prints odd ,,,, print 1 to 20 in order


class NumberPrinter {
    private int number = 1;
    private final int MAX = 20;

    public synchronized void printOdd() throws InterruptedException {
        while (number <= MAX) {
            if (number % 2 == 0) {
                wait(); // wait if it's not odd's turn
            } else {
                System.out.println("Odd: " + number++);
                notify(); // wake up even thread
            }
        }
    }

    public synchronized void printEven() throws InterruptedException {
        while (number <= MAX) {
            if (number % 2 == 1) {
                wait(); // wait if it's not even's turn
            } else {
                System.out.println("Even: " + number++);
                notify(); // wake up odd thread
            }
        }
    }
}

public class Main {
    public static void main(String[] args) {
        NumberPrinter printer = new NumberPrinter();

        Thread oddThread = new Thread(new Runnable() {

    @Override
    public void run() {
        try {
            printer.printOdd();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});

        Thread evenThread = new Thread(() -> {
            try {
                printer.printEven();
            } catch (InterruptedException e) { e.printStackTrace(); }
        });

        oddThread.start();
        evenThread.start();
    }
}


---------------------

# code for deadlock


class A {
    synchronized void methodA(B b) {
        System.out.println("Thread 1: Holding lock A...");
        try { Thread.sleep(100); } catch (Exception e) {}
        System.out.println("Thread 1: Waiting for lock B...");
        b.last();
    }

    synchronized void last() {
        System.out.println("In method A");
    }
}

class B {
    synchronized void methodB(A a) {
        System.out.println("Thread 2: Holding lock B...");
        try { Thread.sleep(100); } catch (Exception e) {}
        System.out.println("Thread 2: Waiting for lock A...");
        a.last();
    }

    synchronized void last() {
        System.out.println("In method B");
    }
}

public class DeadlockExample {
    public static void main(String[] args) {
        A a = new A();
        B b = new B();

        Thread t1 = new Thread(() -> a.methodA(b));
        Thread t2 = new Thread(() -> b.methodB(a));

        t1.start();
        t2.start();
    }
}

---------------------






