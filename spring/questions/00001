give springboot microservices questions asked in interview relevant to industry development
Spring Boot Microservices said:

Understood. Iâ€™ll prepare a comprehensive list of Spring Boot microservices interview questions that are both industry-relevant and commonly asked during technical interviews in 2024â€“2025. Iâ€™ll group them by categories, from fundamentals to advanced, so you can prepare systematically.

ðŸ”¹ Spring Boot & Microservices â€“ Interview Questions
1. Core Spring Boot

What are the advantages of using Spring Boot over traditional Spring?

How does @SpringBootApplication work internally?

How do you configure properties in Spring Boot? Difference between application.properties and application.yml.

How does Spring Boot auto-configuration work?

What are starter dependencies in Spring Boot? Give examples.

How do you override default auto-configuration in Spring Boot?

What are profiles in Spring Boot? How do you implement environment-specific configurations?

2. Spring MVC vs Spring WebFlux

Difference between Spring MVC (Servlet stack) and WebFlux (Reactive stack).

When would you choose WebFlux over MVC?

Explain DispatcherServlet flow in Spring MVC.

How does backpressure work in WebFlux?

What is the difference between Mono and Flux in Project Reactor?

3. REST API Development

How do you design and implement REST APIs in Spring Boot?

Difference between @Controller, @RestController, and @ResponseBody.

How do you handle exception handling in REST APIs (@ControllerAdvice, @ExceptionHandler)?

How do you implement API versioning in Spring Boot?

How do you document APIs with OpenAPI/Swagger?

4. Data Layer (JPA & R2DBC)

Difference between Spring Data JPA and Spring Data JDBC.

What is the N+1 query problem in JPA? How do you solve it?

How do you handle transactions in Spring Boot (@Transactional)?

What are the differences between blocking (JPA) and non-blocking (R2DBC) repositories?

Explain optimistic vs pessimistic locking in databases.

5. Microservices Architecture

What is a microservice? How is it different from a monolith?

How do services communicate with each other? (REST, gRPC, messaging)

How do you implement service discovery? (Eureka, Consul, Kubernetes DNS)

How do you implement centralized configuration in microservices? (Spring Cloud Config, Vault)

How do you implement API Gateway? (Spring Cloud Gateway, Nginx, Istio)

Explain circuit breaker pattern and how you implement it in Spring Boot (Resilience4j).

What is the Saga pattern? How do you implement distributed transactions in microservices?

Difference between synchronous (REST) and asynchronous (Kafka, RabbitMQ) communication in microservices.

6. Security

How do you implement authentication and authorization in Spring Boot microservices?

Difference between session-based auth, JWT, and OAuth2.0.

How do you secure REST APIs with Spring Security?

What is the difference between OAuth2 and OpenID Connect?

How do you propagate user identity across microservices?

7. Resilience & Scalability

What is rate limiting? How do you implement it in Spring Boot?

Explain retry, fallback, and circuit breaker in microservices.

How do you achieve distributed caching in microservices? (Redis, Hazelcast)

How do you handle idempotency in APIs?

How do you design a system for zero-downtime deployment?

8. Observability

How do you log in a distributed microservices environment?

How do you implement centralized logging (ELK, Loki, etc.)?

How do you monitor microservices (Micrometer, Prometheus, Grafana)?

What is distributed tracing? How do you implement it? (Zipkin, Jaeger, OpenTelemetry)

How do you detect performance bottlenecks in microservices?

9. Cloud-Native & Deployment

How do you deploy Spring Boot microservices in Docker and Kubernetes?

What is a sidecar pattern in Kubernetes?

How do you scale microservices horizontally and vertically?

How do you manage configuration and secrets in Kubernetes?

What are liveness and readiness probes in Kubernetes?

10. Advanced & Scenario-Based

How do you design an API that needs to handle 1M requests per minute?

How do you handle data consistency across multiple microservices?

How do you migrate from a monolith to microservices step by step?

How do you ensure backward compatibility when updating APIs?

How do you handle eventual consistency in distributed systems?

Given a scenario: "User places an order â†’ payment service â†’ inventory service â†’ notification service"

How would you design this flow using microservices?

Would you choose orchestration (via a central service) or choreography (event-driven)? Why?

âœ… These are the industry-standard interview questions for Spring Boot 3 and microservices, especially in companies building scalable, cloud-native systems.

Would you like me to also prepare detailed answers with code examples for the top 20 most frequently asked questions so that you have a ready reference for interviews?

You said:
answer them
Spring Boot Microservices said:
Thought for 4 seconds
Spring Boot Microservices â€” Answers (concise, interview-ready)

Below are clear, focused answers to the question set you asked for. I kept each answer practical and example-driven where it matters. Use these as short talking points in interviews and as starting points for deeper discussion.

1. Core Spring Boot

Q: What are the advantages of using Spring Boot over traditional Spring?

Auto-configuration reduces boilerplate; opinionated starters provide tested dependency sets.

Embedded servers (Tomcat/Jetty/Undertow) make packaging as a runnable JAR trivial.

Convention-over-configuration: property-driven behavior and production-ready defaults (metrics, health checks).

Rapid bootstrapping of microservices with minimal XML/config.

Q: How does @SpringBootApplication work internally?

@SpringBootApplication is a meta-annotation combining @Configuration, @EnableAutoConfiguration, and @ComponentScan.

@EnableAutoConfiguration triggers AutoConfigurationImportSelector which loads auto-configuration classes based on classpath and beans.

Q: How do you configure properties? Differences between application.properties and application.yml.

Spring Boot reads application.properties or application.yml from classpath:/, external locations, and profile-specific files (application-{profile}.yml).

properties is flat key=value; yml supports nested structure and is more readable for complex configs. Both map to @ConfigurationProperties / Environment.

Q: How does Spring Boot auto-configuration work?

Auto-config classes (annotated with @Configuration) are conditionally loaded using @Conditional annotations (e.g., @ConditionalOnClass, @ConditionalOnProperty).

The spring.factories or (newer) spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports files list auto-config candidates.

Q: What are starter dependencies? Examples.

Starters are curated pom dependencies that pull in a set of useful libraries. Examples: spring-boot-starter-web, spring-boot-starter-data-jpa, spring-boot-starter-security.

Q: How do you override default auto-configuration?

Provide your own @Bean of the same type, use properties (spring.autoconfigure.exclude), or implement @AutoConfigurationImportFilter / conditional properties.

Q: What are profiles?

Profiles allow environment-specific config. Activate with spring.profiles.active or JVM env. Use @Profile on beans or application-{profile}.yml for properties.

2. Spring MVC vs Spring WebFlux

Q: Difference between Spring MVC (Servlet) and WebFlux (Reactive).

MVC: Blocking, thread-per-request model based on Servlet API. Best when using blocking I/O (JPA, JDBC).

WebFlux: Non-blocking, reactive, event-loop model using Reactor (Mono, Flux). Best for high-concurrency, I/O-bound services or streaming.

Q: When choose WebFlux over MVC?

Choose WebFlux when you expect massive concurrency with limited threads, when external calls are non-blocking/reactive, or when you need streaming/reactive pipelines end-to-end.

Q: Explain DispatcherServlet flow in Spring MVC.

Client â†’ Servlet container â†’ DispatcherServlet â†’ HandlerMapping resolves controller â†’ HandlerAdapter invokes controller â†’ ViewResolver renders view â†’ Response.

Q: How does backpressure work in WebFlux?

Reactor implements Reactive Streamsâ€”subscribers request N items from publishers. Upstream honors demand signals to avoid overwhelming downstream.

Q: Difference between Mono and Flux.

Mono<T>: 0..1 asynchronous value.

Flux<T>: 0..N asynchronous sequence.

3. REST API Development

Q: How to design/implement REST APIs in Spring Boot?

Use @RestController, map endpoints with @GetMapping/@PostMapping, validate inputs (@Valid), return ResponseEntity<T> with proper status codes, and follow resource naming (nouns, plural). Provide HATEOAS if needed.

Q: Difference @Controller, @RestController, @ResponseBody.

@Controller + view rendering (Thymeleaf). @RestController = @Controller + @ResponseBody (responses serialized to JSON). @ResponseBody on a method returns body directly.

Q: Exception handling (@ControllerAdvice, @ExceptionHandler).

Use @ControllerAdvice with @ExceptionHandler(ExceptionType.class) methods to centralize exception â†’ HTTP response mapping and error payloads.

Q: API versioning strategies.

URI versioning (/v1/...), header versioning (Accept), media-type versioning, or request parameter. Prefer URI or content negotiation; design for backward compatibility.

Q: Document APIs with OpenAPI/Swagger.

Use springdoc-openapi or springfox to generate OpenAPI docs. Add @Operation, @Schema annotations and expose UI via Swagger UI.

4. Data Layer (JPA & R2DBC)

Q: Spring Data JPA vs Spring Data JDBC.

JPA: ORM with first-level cache, lazy loading, entity lifecycle. Complex mapping, convenient for domain modeling.

JDBC/Data JDBC: simpler, explicit SQL, fewer surprisesâ€”better for highly-performant, predictable SQL.

Q: N+1 query problem & solutions.

Cause: lazy associations fetched per parent.

Fix: use JOIN FETCH in JPQL, entity graph (@EntityGraph), DTO projection queries, or enable batch fetching (hibernate.default_batch_fetch_size).

Q: Transactions in Spring (@Transactional).

@Transactional on class/method starts a transaction (by proxy). Propagation modes (REQUIRED, REQUIRES_NEW) and isolation levels control behavior. Beware of self-invocation (wonâ€™t apply proxy).

Q: Blocking (JPA) vs non-blocking (R2DBC) repositories.

JPA uses blocking JDBC drivers (thread per DB call). R2DBC provides reactive DB access; use with WebFlux to keep stack non-blocking. Transaction semantics differâ€”use reactive transaction managers.

Q: Optimistic vs pessimistic locking.

Optimistic: version field (@Version) detects concurrent updates; fail and retry on conflict.

Pessimistic: DB locks rows (SELECT FOR UPDATE) to prevent concurrent accessâ€”use when conflicts are frequent.

5. Microservices Architecture

Q: Microservice vs monolith.

Microservice: small, independently deployable services bounded by business capability. Monolith: single deployable app. Tradeoffs: deployment independence and scaling vs complexity (distributed concerns).

Q: Service communication methods.

Synchronous: REST, gRPC. Asynchronous: message broker (Kafka, RabbitMQ). Choose based on coupling, latency, and consistency needs.

Q: Service discovery (Eureka, Consul, Kubernetes DNS).

Use discovery (Eureka/Consul) or rely on platform DNS (Kubernetes). Clients resolve services dynamically; for client-side load balancing use Spring Cloud LoadBalancer or Ribbon (legacy).

Q: Centralized configuration (Spring Cloud Config, Vault).

Spring Cloud Config serves properties from a central repo (git). HashiCorp Vault handles secrets with rotation and RBAC.

Q: API Gateway (Spring Cloud Gateway, Istio).

Gateway is the single ingress entry; handles routing, auth, rate limiting, and resilience. Use Spring Cloud Gateway for Spring-native filters; Istio provides richer service mesh features.

Q: Circuit breaker pattern (Resilience4j).

Circuit breaker monitors failure rate; opens to avoid cascading failures, after a wait period transitions to half-open and tests. Resilience4j integrates with Spring via annotations or functional APIs.

Q: Saga pattern / distributed transactions.

Saga: split a global transaction into a sequence of local transactions with compensating actions. Two styles: choreography (events) or orchestration (central coordinator).

Q: Sync vs async communication.

Sync (REST/gRPC) simpler for immediate results, but couples latency. Async (events) decouples, improves resilience and scalability, but requires eventual consistency.

6. Security

Q: Authentication/authorization in microservices.

Use centralized auth (OAuth2 / OpenID Connect) with tokens (JWT or reference tokens). API Gateway handles authentication and propagates identity via headers. Microservices verify tokens and enforce authorization (scopes/roles).

Q: Session-based vs JWT vs OAuth2.0.

Session: server stores session state; not ideal for microservices.

JWT: stateless, self-contained claims; good for scale but revocation is difficult.

OAuth2/OIDC: industry standard for authorization/authentication with refresh tokens, scopes, and central identity provider.

Q: Secure REST APIs with Spring Security.

Use spring-boot-starter-oauth2-resource-server to validate JWTs, @PreAuthorize for method-level checks, and configure CORS, CSRF as appropriate.

Q: OAuth2 vs OpenID Connect.

OAuth2: authorization framework. OIDC: identity layer on top of OAuth2 to provide user identity (ID token).

Q: Propagate identity across services.

Use propagated JWT or a secure short-lived token in headers (e.g., Authorization: Bearer ...). For internal calls, consider mTLS or SPIFFE for stronger auth.

7. Resilience & Scalability

Q: Rate limiting implementations.

Edge: gateway-level rate limiting (Redis-backed). Service: token-bucket (Bucket4j) with Redis for distributed state. Return 429 with Retry-After.

Q: Retry, fallback, circuit breaker.

Use Resilience4j or Spring Retry: configure retry attempts and backoff. Fallback methods provide graceful degradation. Circuit breakers prevent repeated failing calls.

Q: Distributed caching (Redis, Hazelcast).

Use Redis for global cache with TTL and eviction. Hazelcast offers in-memory distributed maps and optional near-cache for low latency.

Q: Idempotency in APIs.

Use idempotency keys (client-supplied) stored with request result. Ensure POST semantics are safe to replay. Implement at gateway or service layer.

Q: Zero-downtime deployment.

Rolling deployments, blue/green, or canary releases. Use health checks and readiness probes to control traffic to new instances.

8. Observability

Q: Logging in distributed systems.

Structured logs (JSON), correlate via a request ID (X-Request-ID) propagated across services. Use centralized aggregator (ELK, Loki).

Q: Centralized logging.

Ship logs to ELK (Elasticsearch + Logstash + Kibana), or Grafana+Loki. Use Filebeat/Fluentd to forward.

Q: Monitoring (Micrometer, Prometheus, Grafana).

Use Micrometer to expose metrics (HTTP server, JVM, custom business metrics). Scrape with Prometheus and visualize in Grafana.

Q: Distributed tracing (Zipkin, Jaeger, OpenTelemetry).

Use OpenTelemetry or Brave/Zipkin to trace requests across services; include trace/span IDs in logs and HTTP headers.

Q: Detect performance bottlenecks.

Use metrics (latency histograms), profiling, tracing to find hot services/endpoints and slow DB queries.

9. Cloud-Native & Deployment

Q: Deploy in Docker/Kubernetes.

Containerize with minimal JRE base image, keep 1 service per container. Deploy as Deployments/StatefulSets with Services for discovery.

Q: Sidecar pattern.

Co-locate helper containers (e.g., envoy, log collector) with app container to add cross-cutting concerns.

Q: Scaling microservices.

Horizontal scaling: add replicas behind a load balancer. Vertical scaling: increase resources. Use autoscalers (HPA/VPA) with resource-based metrics.

Q: Manage config and secrets in Kubernetes.

Use ConfigMap for non-sensitive config and Secret (or external secret stores like Vault) for secrets. Avoid baking secrets into images.

Q: Liveness and readiness probes.

Liveness: determines if container should be restarted. Readiness: determines if instance should receive traffic. Implement simple endpoints that validate service readiness.

10. Advanced & Scenario-Based

Q: Design an API for 1M requests per minute (brief).

Use autoscaling, stateless services, autoscaled DB read replicas, caching (CDN + edge cache), API gateway rate limiting, backpressure and queueing; prefer asynchronous processing and use partitioned topics (Kafka) for ingestion.

Q: Data consistency across microservices.

Prefer eventual consistency via events; if strong consistency required use synchronous calls/transactions or patterns like two-phase commit (rare). For many systems, Saga is the pragmatic choice.

Q: Monolith â†’ microservices migration steps.

Identify bounded contexts, extract least-coupled capabilities as services, migrate data and traffic gradually, add API gateway, maintain compatibility and monitoring throughout.

Q: Backward compatibility strategies for APIs.

Keep existing endpoints unchanged, add new endpoints or optional fields, use versioning, deprecate carefully with clear timelines and feature flags.

Q: Eventual consistency handling.

Use compensating transactions, idempotent consumers, message ordering where required, and provide user-facing feedback (pending/confirmed states).

Scenario (order flow)

Design: Order Service writes order and emits OrderCreated. Payment Service consumes OrderCreated, processes payment and emits PaymentSucceeded/PaymentFailed. Inventory Service reserves stock when PaymentSucceeded. Notification Service sends email on final events.

Orchestration vs choreography:

Choreography (event-driven) scales well and decouples services â€” good for many services.

Orchestration (central coordinator) simplifies complex multi-step business logic and error handling. Choose based on complexity and transactional needs.

Example snippets (quick reference)

Simple REST controller

@RestController
@RequestMapping("/api/products")
public class ProductController {

    private final ProductService svc;

    public ProductController(ProductService svc) { this.svc = svc; }

    @GetMapping
    public ResponseEntity<List<ProductDto>> list() {
        return ResponseEntity.ok(svc.findAll());
    }

    @PostMapping
    public ResponseEntity<ProductDto> create(@Valid @RequestBody CreateProduct command) {
        ProductDto p = svc.create(command);
        URI location = URI.create("/api/products/" + p.getId());
        return ResponseEntity.created(location).body(p);
    }
}


@ControllerAdvice

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ErrorDto> notFound(EntityNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                             .body(new ErrorDto("NOT_FOUND", ex.getMessage()));
    }
}


Resilience4j circuit breaker (annotation)

@CircuitBreaker(name = "paymentService", fallbackMethod = "fallback")
public PaymentResult callPayment(PaymentRequest req) { ... }

public PaymentResult fallback(PaymentRequest req, Throwable t) { ... }


Bucket4j Redis rate limiting (concept)

Use BucketConfiguration, ProxyManager backed by Redis; check tryConsumeAndReturnRemaining per key (API key / user ID) and return 429 if exceeded.
